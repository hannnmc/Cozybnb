{"version":3,"sources":["../src/reach-combobox.tsx","../src/utils.ts"],"sourcesContent":["/**\n * Welcome to @reach/combobox!\n *\n * Accessible combobox (autocomplete or autosuggest) component for React.\n *\n * A combobox is the combination of an `<input type=\"text\"/>` and a list. The\n * list is designed to help the user arrive at a value, but the value does not\n * necessarily have to come from that list. Don't think of it like a\n * `<select/>`, but more of an `<input type=\"text\"/>` with some suggestions. You\n * can, however, validate that the value comes from the list, that's up to your\n * app.\n *\n * ???: navigate w/ arrows, then hit backspace: should it delete the\n *      autocompleted text or the old value the user had typed?!\n *\n * @see Docs     https://reach.tech/combobox\n * @see Source   https://github.com/reach/reach-ui/tree/main/packages/combobox\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#combobox\n */\n\nimport * as React from \"react\";\nimport {\n\tcreateNamedContext,\n\tcomposeEventHandlers,\n\tisFunction,\n\tmakeId,\n\tnoop,\n\tuseComposedRefs,\n\tuseIsomorphicLayoutEffect as useLayoutEffect,\n\tuseStatefulRefValue,\n\tuseUpdateEffect,\n} from \"@reach/utils\";\nimport type * as Polymorphic from \"@reach/polymorphic\";\nimport {\n\tcreateDescendantContext,\n\tDescendantProvider,\n\tuseDescendant,\n\tuseDescendants,\n\tuseDescendantsInit,\n} from \"@reach/descendants\";\nimport { HighlightWords } from \"./utils\";\nimport { useId } from \"@reach/auto-id\";\nimport { Popover, positionMatchWidth } from \"@reach/popover\";\nimport type { PopoverProps } from \"@reach/popover\";\nimport type { Descendant } from \"@reach/descendants\";\n\ndeclare const __DEV__: boolean;\n\n////////////////////////////////////////////////////////////////////////////////\n// States\n\n// Nothing going on, waiting for the user to type or use the arrow keys\nconst IDLE = \"IDLE\";\n\n// The component is suggesting options as the user types\nconst SUGGESTING = \"SUGGESTING\";\n\n// The user is using the keyboard to navigate the list, not typing\nconst NAVIGATING = \"NAVIGATING\";\n\n// The user is interacting with arbitrary elements inside the popup that\n// are not ComboboxInputs\nconst INTERACTING = \"INTERACTING\";\n\n////////////////////////////////////////////////////////////////////////////////\n// Events\n\n// User cleared the value w/ backspace, but input still has focus\nconst CLEAR = \"CLEAR\";\n\n// User is typing\nconst CHANGE = \"CHANGE\";\n\n// Initial input value change handler for syncing user state with state machine\n// Prevents initial change from sending the user to the NAVIGATING state\n// https://github.com/reach/reach-ui/issues/464\nconst INITIAL_CHANGE = \"INITIAL_CHANGE\";\n\n// User is navigating w/ the keyboard\nconst NAVIGATE = \"NAVIGATE\";\n\n// User can be navigating with keyboard and then click instead, we want the\n// value from the click, not the current nav item\nconst SELECT_WITH_KEYBOARD = \"SELECT_WITH_KEYBOARD\";\nconst SELECT_WITH_CLICK = \"SELECT_WITH_CLICK\";\n\n// Pretty self-explanatory, user can hit escape or blur to close the popover\nconst ESCAPE = \"ESCAPE\";\nconst BLUR = \"BLUR\";\n\n// The user left the input to interact with arbitrary elements inside the popup\nconst INTERACT = \"INTERACT\";\n\nconst FOCUS = \"FOCUS\";\n\nconst OPEN_WITH_BUTTON = \"OPEN_WITH_BUTTON\";\n\nconst OPEN_WITH_INPUT_CLICK = \"OPEN_WITH_INPUT_CLICK\";\n\nconst CLOSE_WITH_BUTTON = \"CLOSE_WITH_BUTTON\";\n\n////////////////////////////////////////////////////////////////////////////////\nconst stateChart: StateChart = {\n\tinitial: IDLE,\n\tstates: {\n\t\t[IDLE]: {\n\t\t\ton: {\n\t\t\t\t[BLUR]: IDLE,\n\t\t\t\t[CLEAR]: IDLE,\n\t\t\t\t[CHANGE]: SUGGESTING,\n\t\t\t\t[INITIAL_CHANGE]: IDLE,\n\t\t\t\t[FOCUS]: SUGGESTING,\n\t\t\t\t[NAVIGATE]: NAVIGATING,\n\t\t\t\t[OPEN_WITH_BUTTON]: SUGGESTING,\n\t\t\t\t[OPEN_WITH_INPUT_CLICK]: SUGGESTING,\n\t\t\t},\n\t\t},\n\t\t[SUGGESTING]: {\n\t\t\ton: {\n\t\t\t\t[CHANGE]: SUGGESTING,\n\t\t\t\t[FOCUS]: SUGGESTING,\n\t\t\t\t[NAVIGATE]: NAVIGATING,\n\t\t\t\t[CLEAR]: IDLE,\n\t\t\t\t[ESCAPE]: IDLE,\n\t\t\t\t[BLUR]: IDLE,\n\t\t\t\t[SELECT_WITH_CLICK]: IDLE,\n\t\t\t\t[INTERACT]: INTERACTING,\n\t\t\t\t[CLOSE_WITH_BUTTON]: IDLE,\n\t\t\t},\n\t\t},\n\t\t[NAVIGATING]: {\n\t\t\ton: {\n\t\t\t\t[CHANGE]: SUGGESTING,\n\t\t\t\t[FOCUS]: SUGGESTING,\n\t\t\t\t[CLEAR]: IDLE,\n\t\t\t\t[BLUR]: IDLE,\n\t\t\t\t[ESCAPE]: IDLE,\n\t\t\t\t[NAVIGATE]: NAVIGATING,\n\t\t\t\t[SELECT_WITH_CLICK]: IDLE,\n\t\t\t\t[SELECT_WITH_KEYBOARD]: IDLE,\n\t\t\t\t[CLOSE_WITH_BUTTON]: IDLE,\n\t\t\t\t[INTERACT]: INTERACTING,\n\t\t\t},\n\t\t},\n\t\t[INTERACTING]: {\n\t\t\ton: {\n\t\t\t\t[CLEAR]: IDLE,\n\t\t\t\t[CHANGE]: SUGGESTING,\n\t\t\t\t[FOCUS]: SUGGESTING,\n\t\t\t\t[BLUR]: IDLE,\n\t\t\t\t[ESCAPE]: IDLE,\n\t\t\t\t[NAVIGATE]: NAVIGATING,\n\t\t\t\t[CLOSE_WITH_BUTTON]: IDLE,\n\t\t\t\t[SELECT_WITH_CLICK]: IDLE,\n\t\t\t},\n\t\t},\n\t},\n};\n\nconst reducer: Reducer = (data: StateData, event: MachineEvent) => {\n\tlet nextState = { ...data, lastEventType: event.type };\n\tswitch (event.type) {\n\t\tcase CHANGE:\n\t\tcase INITIAL_CHANGE:\n\t\t\treturn {\n\t\t\t\t...nextState,\n\t\t\t\tnavigationValue: null,\n\t\t\t\tvalue: event.value,\n\t\t\t};\n\t\tcase NAVIGATE:\n\t\tcase OPEN_WITH_BUTTON:\n\t\tcase OPEN_WITH_INPUT_CLICK:\n\t\t\treturn {\n\t\t\t\t...nextState,\n\t\t\t\tnavigationValue: findNavigationValue(nextState, event),\n\t\t\t};\n\t\tcase CLEAR:\n\t\t\treturn {\n\t\t\t\t...nextState,\n\t\t\t\tvalue: \"\",\n\t\t\t\tnavigationValue: null,\n\t\t\t};\n\t\tcase BLUR:\n\t\tcase ESCAPE:\n\t\t\treturn {\n\t\t\t\t...nextState,\n\t\t\t\tnavigationValue: null,\n\t\t\t};\n\t\tcase SELECT_WITH_CLICK:\n\t\t\treturn {\n\t\t\t\t...nextState,\n\t\t\t\t// if controlled, \"set\" the input to what it already has, and let the\n\t\t\t\t// user do whatever they want\n\t\t\t\tvalue: event.isControlled ? data.value : event.value,\n\t\t\t\tnavigationValue: null,\n\t\t\t};\n\t\tcase SELECT_WITH_KEYBOARD:\n\t\t\treturn {\n\t\t\t\t...nextState,\n\t\t\t\t// if controlled, \"set\" the input to what it already has, and let the\n\t\t\t\t// user do whatever they want\n\t\t\t\tvalue: event.isControlled ? data.value : data.navigationValue,\n\t\t\t\tnavigationValue: null,\n\t\t\t};\n\t\tcase CLOSE_WITH_BUTTON:\n\t\t\treturn {\n\t\t\t\t...nextState,\n\t\t\t\tnavigationValue: null,\n\t\t\t};\n\t\tcase INTERACT:\n\t\t\treturn nextState;\n\t\tcase FOCUS:\n\t\t\treturn {\n\t\t\t\t...nextState,\n\t\t\t\tnavigationValue: findNavigationValue(nextState, event),\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn nextState;\n\t}\n};\n\nfunction popoverIsExpanded(state: State) {\n\treturn [SUGGESTING, NAVIGATING, INTERACTING].includes(state);\n}\n\n/**\n * When we open a list, set the navigation value to the value in the input, if\n * it's in the list, then it'll automatically be highlighted.\n *\n * @param stateData\n * @param event\n */\nfunction findNavigationValue(stateData: StateData, event: MachineEvent) {\n\t// @ts-ignore\n\tif (event.value) {\n\t\t// @ts-ignore\n\t\treturn event.value;\n\t\t// @ts-ignore\n\t} else if (event.persistSelection) {\n\t\treturn stateData.value;\n\t} else {\n\t\treturn null;\n\t}\n}\n\nconst ComboboxDescendantContext = createDescendantContext<ComboboxDescendant>(\n\t\"ComboboxDescendantContext\"\n);\nconst ComboboxContext = createNamedContext(\n\t\"ComboboxContext\",\n\t{} as InternalComboboxContextValue\n);\n\n// Allows us to put the option's value on context so that ComboboxOptionText\n// can work it's highlight text magic no matter what else is rendered around\n// it.\nconst OptionContext = createNamedContext(\n\t\"OptionContext\",\n\t{} as ComboboxOptionContextValue\n);\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Combobox\n *\n * @see Docs https://reach.tech/combobox#combobox\n */\nexport const Combobox = React.forwardRef(\n\t(\n\t\t{\n\t\t\tonSelect,\n\t\t\topenOnFocus = false,\n\t\t\tchildren,\n\t\t\tas: Comp = \"div\",\n\t\t\t\"aria-label\": ariaLabel,\n\t\t\t\"aria-labelledby\": ariaLabelledby,\n\t\t\t...props\n\t\t},\n\t\tforwardedRef\n\t) => {\n\t\tlet [options, setOptions] = useDescendantsInit<ComboboxDescendant>();\n\n\t\t// Need this to focus it\n\t\tlet inputRef = React.useRef<HTMLInputElement>();\n\n\t\tlet popoverRef = React.useRef<HTMLElement>();\n\n\t\tlet buttonRef = React.useRef<HTMLButtonElement>();\n\n\t\t// When <ComboboxInput autocomplete={false} /> we don't want cycle back to\n\t\t// the user's value while navigating (because it's always the user's value),\n\t\t// but we need to know this in useKeyDown which is far away from the prop\n\t\t// here, so we do something sneaky and write it to this ref on context so we\n\t\t// can use it anywhere else 😛. Another new trick for me and I'm excited\n\t\t// about this one too!\n\t\tlet autocompletePropRef = React.useRef(false);\n\n\t\tlet persistSelectionRef = React.useRef(false);\n\n\t\tlet defaultData: StateData = {\n\t\t\t// The value the user has typed. We derive this also when the developer is\n\t\t\t// controlling the value of ComboboxInput.\n\t\t\tvalue: \"\",\n\t\t\t// the value the user has navigated to with the keyboard\n\t\t\tnavigationValue: null,\n\t\t};\n\n\t\tlet [state, data, transition] = useReducerMachine(\n\t\t\tstateChart,\n\t\t\treducer,\n\t\t\tdefaultData\n\t\t);\n\n\t\tuseFocusManagement(data.lastEventType, inputRef);\n\n\t\tlet id = useId(props.id);\n\t\tlet listboxId = id ? makeId(\"listbox\", id) : \"listbox\";\n\t\tlet isControlledRef = React.useRef<boolean>(false);\n\t\tlet isExpanded = popoverIsExpanded(state);\n\n\t\tlet context: InternalComboboxContextValue = {\n\t\t\tariaLabel,\n\t\t\tariaLabelledby,\n\t\t\tautocompletePropRef,\n\t\t\tbuttonRef,\n\t\t\tcomboboxId: id,\n\t\t\tdata,\n\t\t\tinputRef,\n\t\t\tisExpanded,\n\t\t\tlistboxId,\n\t\t\tonSelect: onSelect || noop,\n\t\t\topenOnFocus,\n\t\t\tpersistSelectionRef,\n\t\t\tpopoverRef,\n\t\t\tstate,\n\t\t\ttransition,\n\t\t\tisControlledRef,\n\t\t};\n\n\t\treturn (\n\t\t\t<DescendantProvider\n\t\t\t\tcontext={ComboboxDescendantContext}\n\t\t\t\titems={options}\n\t\t\t\tset={setOptions}\n\t\t\t>\n\t\t\t\t<ComboboxContext.Provider value={context}>\n\t\t\t\t\t<Comp\n\t\t\t\t\t\t{...props}\n\t\t\t\t\t\tdata-reach-combobox=\"\"\n\t\t\t\t\t\tdata-state={getDataState(state)}\n\t\t\t\t\t\tdata-expanded={isExpanded || undefined}\n\t\t\t\t\t\tref={forwardedRef}\n\t\t\t\t\t>\n\t\t\t\t\t\t{isFunction(children)\n\t\t\t\t\t\t\t? children({\n\t\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\t\tisExpanded,\n\t\t\t\t\t\t\t\t\tnavigationValue: data.navigationValue ?? null,\n\t\t\t\t\t\t\t\t\tstate,\n\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t: children}\n\t\t\t\t\t</Comp>\n\t\t\t\t</ComboboxContext.Provider>\n\t\t\t</DescendantProvider>\n\t\t);\n\t}\n) as Polymorphic.ForwardRefComponent<\"div\", ComboboxProps>;\n\n/**\n * @see Docs https://reach.tech/combobox#combobox-props\n */\nexport interface ComboboxProps {\n\t/**\n\t * @see Docs https://reach.tech/combobox#combobox-children\n\t */\n\tchildren:\n\t\t| React.ReactNode\n\t\t| ((props: ComboboxContextValue) => React.ReactNode);\n\t/**\n\t * Called with the selection value when the user makes a selection from the\n\t * list.\n\t *\n\t * @see Docs https://reach.tech/combobox#combobox-onselect\n\t */\n\tonSelect?(value: ComboboxValue): void;\n\t/**\n\t * If true, the popover opens when focus is on the text box.\n\t *\n\t * @see Docs https://reach.tech/combobox#combobox-openonfocus\n\t */\n\topenOnFocus?: boolean;\n\t/**\n\t * Defines a string value that labels the current element.\n\t * @see Docs https://reach.tech/combobox#accessibility\n\t */\n\t\"aria-label\"?: string;\n\t/**\n\t * Identifies the element (or elements) that labels the current element.\n\t * @see Docs https://reach.tech/combobox#accessibility\n\t */\n\t\"aria-labelledby\"?: string;\n}\n\nCombobox.displayName = \"Combobox\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxInput\n *\n * Wraps an `<input/>` with a couple extra props that work with the combobox.\n *\n * @see Docs https://reach.tech/combobox#comboboxinput\n */\nexport const ComboboxInput = React.forwardRef(\n\t(\n\t\t{\n\t\t\tas: Comp = \"input\",\n\t\t\tselectOnClick = false,\n\t\t\tautocomplete = true,\n\t\t\tonClick,\n\t\t\tonChange,\n\t\t\tonKeyDown,\n\t\t\tonBlur,\n\t\t\tonFocus,\n\t\t\tvalue: controlledValue,\n\t\t\t...props\n\t\t},\n\t\tforwardedRef\n\t) => {\n\t\t// https://github.com/reach/reach-ui/issues/464\n\t\tlet { current: initialControlledValue } = React.useRef(controlledValue);\n\t\tlet controlledValueChangedRef = React.useRef(false);\n\t\tuseUpdateEffect(() => {\n\t\t\tcontrolledValueChangedRef.current = true;\n\t\t}, [controlledValue]);\n\n\t\tlet {\n\t\t\tdata: { navigationValue, value, lastEventType },\n\t\t\tinputRef,\n\t\t\tstate,\n\t\t\ttransition,\n\t\t\tlistboxId,\n\t\t\tautocompletePropRef,\n\t\t\topenOnFocus,\n\t\t\tisExpanded,\n\t\t\tariaLabel,\n\t\t\tariaLabelledby,\n\t\t\tpersistSelectionRef,\n\t\t\tisControlledRef,\n\t\t} = React.useContext(ComboboxContext);\n\n\t\tlet ref = useComposedRefs(inputRef, forwardedRef);\n\n\t\t// Because we close the List on blur, we need to track if the blur is\n\t\t// caused by clicking inside the list, and if so, don't close the List.\n\t\tlet selectOnClickRef = React.useRef(false);\n\n\t\tlet handleKeyDown = useKeyDown();\n\n\t\tlet handleBlur = useBlur();\n\n\t\tlet isControlled = typeof controlledValue !== \"undefined\";\n\t\tlet wasInitiallyControlled = typeof initialControlledValue !== \"undefined\";\n\n\t\tif (__DEV__) {\n\t\t\tif (!isControlled && wasInitiallyControlled) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"ComboboxInput is changing from controlled to uncontrolled. ComboboxInput should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled ComboboxInput for the lifetime of the component. Check the `value` prop being passed in.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (isControlled && !wasInitiallyControlled) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"ComboboxInput is changing from uncontrolled to controlled. ComboboxInput should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled ComboboxInput for the lifetime of the component. Check the `value` prop being passed in.\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tReact.useEffect(() => {\n\t\t\tisControlledRef.current = isControlled;\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t}, [isControlled]);\n\n\t\t// Layout effect should be SSR-safe here because we don't actually do\n\t\t// anything with this ref that involves rendering until after we've\n\t\t// let the client hydrate in nested components.\n\t\tuseLayoutEffect(() => {\n\t\t\tautocompletePropRef.current = autocomplete;\n\t\t}, [autocomplete, autocompletePropRef]);\n\n\t\tlet handleValueChange = React.useCallback(\n\t\t\t(value: ComboboxValue) => {\n\t\t\t\tif (value.trim() === \"\") {\n\t\t\t\t\ttransition(CLEAR, { isControlled });\n\t\t\t\t} else if (\n\t\t\t\t\tvalue === initialControlledValue &&\n\t\t\t\t\t!controlledValueChangedRef.current\n\t\t\t\t) {\n\t\t\t\t\ttransition(INITIAL_CHANGE, { value });\n\t\t\t\t} else {\n\t\t\t\t\ttransition(CHANGE, { value });\n\t\t\t\t}\n\t\t\t},\n\t\t\t[initialControlledValue, transition, isControlled]\n\t\t);\n\n\t\tReact.useEffect(() => {\n\t\t\t// If they are controlling the value we still need to do our transitions,\n\t\t\t// so  we have this derived state to emulate onChange of the input as we\n\t\t\t// receive new `value`s ...[*]\n\t\t\tif (\n\t\t\t\tisControlled &&\n\t\t\t\tcontrolledValue !== value &&\n\t\t\t\t// https://github.com/reach/reach-ui/issues/481\n\t\t\t\t(controlledValue!.trim() === \"\" ? (value || \"\").trim() !== \"\" : true)\n\t\t\t) {\n\t\t\t\thandleValueChange(controlledValue!);\n\t\t\t}\n\t\t}, [controlledValue, handleValueChange, isControlled, value]);\n\n\t\t// If a form is reset, we'll need to manually clear the value since we are\n\t\t// controlling it internally.\n\t\tReact.useEffect(() => {\n\t\t\tlet form = inputRef.current?.form;\n\t\t\tif (!form) return;\n\n\t\t\tfunction handleReset(event: Event) {\n\t\t\t\ttransition(CLEAR, { isControlled });\n\t\t\t}\n\n\t\t\tform.addEventListener(\"reset\", handleReset);\n\t\t\treturn () => {\n\t\t\t\tform?.removeEventListener(\"reset\", handleReset);\n\t\t\t};\n\t\t}, [inputRef, isControlled, transition]);\n\n\t\t// [*]... and when controlled, we don't trigger handleValueChange as the\n\t\t// user types, instead the developer controls it with the normal input\n\t\t// onChange prop\n\t\tfunction handleChange(event: React.ChangeEvent<HTMLInputElement>) {\n\t\t\tlet { value } = event.target;\n\t\t\tif (!isControlled) {\n\t\t\t\thandleValueChange(value);\n\t\t\t}\n\t\t}\n\n\t\tfunction handleFocus() {\n\t\t\tif (selectOnClick) {\n\t\t\t\tselectOnClickRef.current = true;\n\t\t\t}\n\n\t\t\t// If we select an option with click, useFocusManagement will focus the\n\t\t\t// input, in those cases we don't want to cause the menu to open back up,\n\t\t\t// so we guard behind these states.\n\t\t\tif (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {\n\t\t\t\ttransition(FOCUS, {\n\t\t\t\t\tpersistSelection: persistSelectionRef.current,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction handleClick() {\n\t\t\tif (selectOnClickRef.current) {\n\t\t\t\tselectOnClickRef.current = false;\n\t\t\t\tinputRef.current?.select();\n\t\t\t}\n\n\t\t\tif (openOnFocus && state === IDLE) {\n\t\t\t\ttransition(OPEN_WITH_INPUT_CLICK);\n\t\t\t}\n\t\t}\n\n\t\tlet inputValue =\n\t\t\tautocomplete && (state === NAVIGATING || state === INTERACTING)\n\t\t\t\t? // When idle, we don't have a navigationValue on ArrowUp/Down\n\t\t\t\t  navigationValue || controlledValue || value\n\t\t\t\t: controlledValue || value;\n\n\t\treturn (\n\t\t\t<Comp\n\t\t\t\taria-activedescendant={\n\t\t\t\t\tnavigationValue ? String(makeHash(navigationValue)) : undefined\n\t\t\t\t}\n\t\t\t\taria-autocomplete=\"both\"\n\t\t\t\taria-controls={listboxId}\n\t\t\t\taria-expanded={isExpanded}\n\t\t\t\taria-haspopup=\"listbox\"\n\t\t\t\taria-label={ariaLabel}\n\t\t\t\taria-labelledby={ariaLabel ? undefined : ariaLabelledby}\n\t\t\t\trole=\"combobox\"\n\t\t\t\t{...props}\n\t\t\t\tdata-reach-combobox-input=\"\"\n\t\t\t\tdata-state={getDataState(state)}\n\t\t\t\tref={ref}\n\t\t\t\tonBlur={composeEventHandlers(onBlur, handleBlur)}\n\t\t\t\tonChange={composeEventHandlers(onChange, handleChange)}\n\t\t\t\tonClick={composeEventHandlers(onClick, handleClick)}\n\t\t\t\tonFocus={composeEventHandlers(onFocus, handleFocus)}\n\t\t\t\tonKeyDown={composeEventHandlers(onKeyDown, handleKeyDown)}\n\t\t\t\tvalue={inputValue || \"\"}\n\t\t\t/>\n\t\t);\n\t}\n) as Polymorphic.ForwardRefComponent<\"input\", ComboboxInputProps>;\n\n/**\n * @see Docs https://reach.tech/combobox#comboboxinput-props\n */\nexport interface ComboboxInputProps {\n\t/**\n\t * If true, when the user clicks inside the text box the current value will\n\t * be selected. Use this if the user is likely to delete all the text anyway\n\t * (like the URL bar in browsers).\n\t *\n\t * However, if the user is likely to want to tweak the value, leave this\n\t * false, like a google search--the user is likely wanting to edit their\n\t * search, not replace it completely.\n\t *\n\t * @see Docs https://reach.tech/combobox#comboboxinput-selectonclick\n\t */\n\tselectOnClick?: boolean;\n\t/**\n\t * Determines if the value in the input changes or not as the user navigates\n\t * with the keyboard. If true, the value changes, if false the value doesn't\n\t * change.\n\t *\n\t * Set this to false when you don't really need the value from the input but\n\t * want to populate some other state (like the recipient selector in Gmail).\n\t * But if your input is more like a normal `<input type=\"text\"/>`, then leave\n\t * the `true` default.\n\t *\n\t * @see Docs https://reach.tech/combobox#comboboxinput-autocomplete\n\t */\n\tautocomplete?: boolean;\n\t/**\n\t * @see Docs https://reach.tech/combobox#comboboxinput-value\n\t */\n\tvalue?: ComboboxValue;\n}\n\nComboboxInput.displayName = \"ComboboxInput\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxPopover\n *\n * Contains the popup that renders the list. Because some UI needs to render\n * more than the list in the popup, you need to render one of these around the\n * list. For example, maybe you want to render the number of results suggested.\n *\n * @see Docs https://reach.tech/combobox#comboboxpopover\n */\nexport const ComboboxPopover = React.forwardRef(\n\t(\n\t\t{\n\t\t\tas: Comp = \"div\",\n\t\t\tchildren,\n\t\t\tportal = true,\n\t\t\tonKeyDown,\n\t\t\tonBlur,\n\t\t\tposition = positionMatchWidth,\n\t\t\t...props\n\t\t},\n\t\tforwardedRef\n\t) => {\n\t\tlet { popoverRef, inputRef, isExpanded, state } =\n\t\t\tReact.useContext(ComboboxContext);\n\t\tlet ref = useComposedRefs(popoverRef, forwardedRef);\n\t\tlet handleKeyDown = useKeyDown();\n\t\tlet handleBlur = useBlur();\n\n\t\tlet sharedProps = {\n\t\t\t\"data-reach-combobox-popover\": \"\",\n\t\t\t\"data-state\": getDataState(state),\n\t\t\tonKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),\n\t\t\tonBlur: composeEventHandlers(onBlur, handleBlur),\n\t\t\t// Instead of conditionally rendering the popover we use the `hidden` prop\n\t\t\t// because we don't want to unmount on close (from escape or onSelect).\n\t\t\t// However, the developer can conditionally render the ComboboxPopover if\n\t\t\t// they do want to cause mount/unmount based on the app's own data (like\n\t\t\t// results.length or whatever).\n\t\t\thidden: !isExpanded,\n\t\t\ttabIndex: -1,\n\t\t\tchildren,\n\t\t};\n\n\t\treturn portal ? (\n\t\t\t<Popover\n\t\t\t\tas={Comp}\n\t\t\t\t{...props}\n\t\t\t\tref={ref}\n\t\t\t\tdata-expanded={isExpanded || undefined}\n\t\t\t\tposition={position}\n\t\t\t\ttargetRef={inputRef}\n\t\t\t\tunstable_skipInitialPortalRender\n\t\t\t\t{...sharedProps}\n\t\t\t/>\n\t\t) : (\n\t\t\t<Comp ref={ref} {...props} {...sharedProps} />\n\t\t);\n\t}\n) as Polymorphic.ForwardRefComponent<\n\t\"div\",\n\tComboboxPopoverProps &\n\t\tPartial<Omit<PopoverProps, \"unstable_skipInitialRender\">>\n>;\n\nComboboxPopover.displayName = \"ComboboxPopover\";\n\n/**\n * @see Docs https://reach.tech/combobox#comboboxpopover-props\n */\nexport interface ComboboxPopoverProps {\n\t/**\n\t * If you pass `<ComboboxPopover portal={false} />` the popover will not\n\t * render inside of a portal, but in the same order as the React tree. This\n\t * is mostly useful for styling the entire component together, like the pink\n\t * focus outline in the example earlier in this page.\n\t *\n\t * @see Docs https://reach.tech/combobox#comboboxpopover-portal\n\t */\n\tportal?: boolean;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxList\n *\n * Contains the `ComboboxOption` elements and sets up the proper aria attributes\n * for the list.\n *\n * @see Docs https://reach.tech/combobox#comboboxlist\n */\nexport const ComboboxList = React.forwardRef(\n\t(\n\t\t{\n\t\t\t// when true, and the list opens again, the option with a matching value\n\t\t\t// will be automatically highlighted.\n\t\t\tpersistSelection = false,\n\t\t\tas: Comp = \"ul\",\n\t\t\t...props\n\t\t},\n\t\tforwardedRef\n\t) => {\n\t\tlet { persistSelectionRef, listboxId } = React.useContext(ComboboxContext);\n\n\t\tif (persistSelection) {\n\t\t\tpersistSelectionRef.current = true;\n\t\t}\n\n\t\treturn (\n\t\t\t<Comp\n\t\t\t\trole=\"listbox\"\n\t\t\t\t{...props}\n\t\t\t\tref={forwardedRef}\n\t\t\t\tdata-reach-combobox-list=\"\"\n\t\t\t\tid={listboxId}\n\t\t\t/>\n\t\t);\n\t}\n) as Polymorphic.ForwardRefComponent<\"ul\", ComboboxListProps>;\n\n/**\n * @see Docs https://reach.tech/combobox#comboboxlist-props\n */\nexport interface ComboboxListProps {\n\t/**\n\t * Defaults to false. When true and the list is opened, if an option's value\n\t * matches the value in the input, it will automatically be highlighted and\n\t * be the starting point for any keyboard navigation of the list.\n\t *\n\t * This allows you to treat a Combobox more like a `<select>` than an\n\t * `<input/>`, but be mindful that the user is still able to put any\n\t * arbitrary value into the input, so if the only valid values for the input\n\t * are from the list, your app will need to do that validation on blur or\n\t * submit of the form.\n\t *\n\t * @see Docs https://reach.tech/combobox#comboboxlist-persistselection\n\t */\n\tpersistSelection?: boolean;\n}\n\nComboboxList.displayName = \"ComboboxList\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxOption\n *\n * An option that is suggested to the user as they interact with the combobox.\n *\n * @see Docs https://reach.tech/combobox#comboboxoption\n */\nexport const ComboboxOption = React.forwardRef(\n\t(\n\t\t{ as: Comp = \"li\", children, index: indexProp, value, onClick, ...props },\n\t\tforwardedRef\n\t) => {\n\t\tlet {\n\t\t\tonSelect,\n\t\t\tdata: { navigationValue },\n\t\t\ttransition,\n\t\t\tisControlledRef,\n\t\t} = React.useContext(ComboboxContext);\n\n\t\tlet ownRef = React.useRef<HTMLElement | null>(null);\n\n\t\tlet [element, handleRefSet] = useStatefulRefValue<HTMLElement | null>(\n\t\t\townRef,\n\t\t\tnull\n\t\t);\n\t\tlet descendant = React.useMemo(() => {\n\t\t\treturn {\n\t\t\t\telement,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t}, [value, element]);\n\t\tlet index = useDescendant(descendant, ComboboxDescendantContext, indexProp);\n\n\t\tlet ref = useComposedRefs(forwardedRef, handleRefSet);\n\n\t\tlet isActive = navigationValue === value;\n\n\t\tlet handleClick = () => {\n\t\t\tonSelect && onSelect(value);\n\t\t\ttransition(SELECT_WITH_CLICK, {\n\t\t\t\tvalue,\n\t\t\t\tisControlled: isControlledRef.current,\n\t\t\t});\n\t\t};\n\n\t\treturn (\n\t\t\t<OptionContext.Provider value={{ value, index }}>\n\t\t\t\t<Comp\n\t\t\t\t\taria-selected={isActive}\n\t\t\t\t\trole=\"option\"\n\t\t\t\t\t{...props}\n\t\t\t\t\tdata-reach-combobox-option=\"\"\n\t\t\t\t\tref={ref}\n\t\t\t\t\tid={String(makeHash(value))}\n\t\t\t\t\tdata-highlighted={isActive ? \"\" : undefined}\n\t\t\t\t\t// Without this the menu will close from `onBlur`, but with it the\n\t\t\t\t\t// element can be `document.activeElement` and then our focus checks in\n\t\t\t\t\t// onBlur will work as intended\n\t\t\t\t\ttabIndex={-1}\n\t\t\t\t\tonClick={composeEventHandlers(onClick, handleClick)}\n\t\t\t\t>\n\t\t\t\t\t{children ? (\n\t\t\t\t\t\tisFunction(children) ? (\n\t\t\t\t\t\t\tchildren({ value, index })\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\tchildren\n\t\t\t\t\t\t)\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<ComboboxOptionText />\n\t\t\t\t\t)}\n\t\t\t\t</Comp>\n\t\t\t</OptionContext.Provider>\n\t\t);\n\t}\n) as Polymorphic.ForwardRefComponent<\"li\", ComboboxOptionProps>;\n\n/**\n * @see Docs https://reach.tech/combobox#comboboxoption-props\n */\nexport interface ComboboxOptionProps {\n\t/**\n\t * Optional. If omitted, the `value` will be used as the children like as:\n\t * `<ComboboxOption value=\"Seattle, Tacoma, Washington\" />`. But if you need\n\t * to control a bit more, you can put whatever children you want, but make\n\t * sure to render a `ComboboxOptionText` as well, so the value is still\n\t * displayed with the text highlighting on the matched portions.\n\t *\n\t * @example\n\t *   <ComboboxOption value=\"Apple\" />\n\t *     🍎 <ComboboxOptionText />\n\t *   </ComboboxOption>\n\t *\n\t * @see Docs https://reach.tech/combobox#comboboxoption-children\n\t */\n\tchildren?:\n\t\t| React.ReactNode\n\t\t| ((props: ComboboxOptionContextValue) => React.ReactNode);\n\t/**\n\t * TODO: Document this!\n\t */\n\tindex?: number;\n\t/**\n\t * The value to match against when suggesting.\n\t *\n\t * @see Docs https://reach.tech/combobox#comboboxoption-value\n\t */\n\tvalue: string;\n}\n\nComboboxOption.displayName = \"ComboboxOption\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxOptionText\n *\n * Renders the value of a `ComboboxOption` as text but with spans wrapping the\n * matching and non-matching segments of text.\n *\n * We don't forwardRef or spread props because we render multiple spans or null,\n * should be fine 🤙\n *\n * @example\n *   <ComboboxOption value=\"Seattle\">\n *     🌧 <ComboboxOptionText />\n *   </ComboboxOption>\n *\n * @see Docs https://reach.tech/combobox#comboboxoptiontext\n */\nexport function ComboboxOptionText() {\n\tlet { value } = React.useContext(OptionContext);\n\tlet {\n\t\tdata: { value: contextValue },\n\t} = React.useContext(ComboboxContext);\n\n\tlet results = React.useMemo(\n\t\t() =>\n\t\t\tHighlightWords.findAll({\n\t\t\t\tsearchWords: escapeRegexp(contextValue || \"\").split(/\\s+/),\n\t\t\t\ttextToHighlight: value,\n\t\t\t}),\n\t\t[contextValue, value]\n\t);\n\n\treturn (\n\t\t<>\n\t\t\t{results.length\n\t\t\t\t? results.map((result, index) => {\n\t\t\t\t\t\tlet str = value.slice(result.start, result.end);\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t\t\tdata-reach-combobox-option-text=\"\"\n\t\t\t\t\t\t\t\tdata-user-value={result.highlight ? true : undefined}\n\t\t\t\t\t\t\t\tdata-suggested-value={result.highlight ? undefined : true}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{str}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t);\n\t\t\t\t  })\n\t\t\t\t: value}\n\t\t</>\n\t);\n}\n\nComboboxOptionText.displayName = \"ComboboxOptionText\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxButton\n */\nexport const ComboboxButton = React.forwardRef(\n\t({ as: Comp = \"button\", onClick, onKeyDown, ...props }, forwardedRef) => {\n\t\tlet { transition, state, buttonRef, listboxId, isExpanded } =\n\t\t\tReact.useContext(ComboboxContext);\n\t\tlet ref = useComposedRefs(buttonRef, forwardedRef);\n\n\t\tlet handleKeyDown = useKeyDown();\n\n\t\tlet handleClick = () => {\n\t\t\tif (state === IDLE) {\n\t\t\t\ttransition(OPEN_WITH_BUTTON);\n\t\t\t} else {\n\t\t\t\ttransition(CLOSE_WITH_BUTTON);\n\t\t\t}\n\t\t};\n\n\t\treturn (\n\t\t\t<Comp\n\t\t\t\taria-controls={listboxId}\n\t\t\t\taria-haspopup=\"listbox\"\n\t\t\t\taria-expanded={isExpanded}\n\t\t\t\t{...props}\n\t\t\t\tdata-reach-combobox-button=\"\"\n\t\t\t\tref={ref}\n\t\t\t\tonClick={composeEventHandlers(onClick, handleClick)}\n\t\t\t\tonKeyDown={composeEventHandlers(onKeyDown, handleKeyDown)}\n\t\t\t/>\n\t\t);\n\t}\n) as Polymorphic.ForwardRefComponent<\"button\", ComboboxButtonProps>;\n\nexport interface ComboboxButtonProps {}\n\nComboboxButton.displayName = \"ComboboxButton\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Move focus back to the input if we start navigating w/ the\n * keyboard after focus has moved to any focusable content in\n * the popup.\n *\n * @param lastEventType\n * @param inputRef\n */\nfunction useFocusManagement(\n\tlastEventType: MachineEventType | undefined,\n\tinputRef: React.MutableRefObject<HTMLInputElement | null | undefined>\n) {\n\t// useLayoutEffect so that the cursor goes to the end of the input instead\n\t// of awkwardly at the beginning, unclear to me why 🤷‍♂️\n\t//\n\t// Should be safe to use here since we're just focusing an input.\n\tuseLayoutEffect(() => {\n\t\tif (\n\t\t\tlastEventType === NAVIGATE ||\n\t\t\tlastEventType === ESCAPE ||\n\t\t\tlastEventType === SELECT_WITH_CLICK ||\n\t\t\tlastEventType === OPEN_WITH_BUTTON\n\t\t) {\n\t\t\tinputRef.current?.focus();\n\t\t}\n\t}, [inputRef, lastEventType]);\n}\n\n/**\n * We want the same events when the input or the popup have focus (HOW COOL ARE\n * HOOKS BTW?) This is probably the hairiest piece but it's not bad.\n */\nfunction useKeyDown() {\n\tlet {\n\t\tdata: { navigationValue },\n\t\tonSelect,\n\t\tstate,\n\t\ttransition,\n\t\tautocompletePropRef,\n\t\tpersistSelectionRef,\n\t\tinputRef,\n\t\tisControlledRef,\n\t} = React.useContext(ComboboxContext);\n\n\tlet options = useDescendants(ComboboxDescendantContext);\n\n\treturn function handleKeyDown(event: React.KeyboardEvent) {\n\t\tlet index = options.findIndex(({ value }) => value === navigationValue);\n\n\t\tfunction getNextOption() {\n\t\t\tlet atBottom = index === options.length - 1;\n\t\t\tif (atBottom) {\n\t\t\t\tif (autocompletePropRef.current) {\n\t\t\t\t\t// Go back to the value the user has typed because we are\n\t\t\t\t\t// autocompleting and they need to be able to get back to what\n\t\t\t\t\t// they had typed w/o having to backspace out.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// cycle through\n\t\t\t\t\treturn getFirstOption();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Go to the next item in the list\n\t\t\t\treturn options[(index + 1) % options.length];\n\t\t\t}\n\t\t}\n\n\t\tfunction getPreviousOption() {\n\t\t\tlet atTop = index === 0;\n\t\t\tif (atTop) {\n\t\t\t\tif (autocompletePropRef.current) {\n\t\t\t\t\t// Go back to the value the user has typed because we are\n\t\t\t\t\t// autocompleting and they need to be able to get back to what\n\t\t\t\t\t// they had typed w/o having to backspace out.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// cycle through\n\t\t\t\t\treturn getLastOption();\n\t\t\t\t}\n\t\t\t} else if (index === -1) {\n\t\t\t\t// displaying the user's value, so go select the last one\n\t\t\t\treturn getLastOption();\n\t\t\t} else {\n\t\t\t\t// normal case, select previous\n\t\t\t\treturn options[(index - 1 + options.length) % options.length];\n\t\t\t}\n\t\t}\n\n\t\tfunction getFirstOption() {\n\t\t\treturn options[0];\n\t\t}\n\n\t\tfunction getLastOption() {\n\t\t\treturn options[options.length - 1];\n\t\t}\n\n\t\t// In standard inputs, ArrowUp/ArrowDown will expand the options list in the\n\t\t// IDLE state and prevent the browser's default behavior (mostly just\n\t\t// scrolling the page). When the input is rendered as a textarea and has a\n\t\t// value containing more than one line, we don't want to do that.\n\t\t// ArrowUp/ArrowDown should move the caret up/dowm in multiline situations.\n\t\tlet textareaHasMultilineValue =\n\t\t\tinputRef.current?.tagName.toUpperCase() === \"TEXTAREA\" &&\n\t\t\tinputRef.current.value.includes(`\\n`);\n\n\t\tswitch (event.key) {\n\t\t\tcase \"ArrowDown\":\n\t\t\t\tif (!options || !options.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (state === IDLE) {\n\t\t\t\t\tif (textareaHasMultilineValue) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Opening a closed list\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\ttransition(NAVIGATE, {\n\t\t\t\t\t\tpersistSelection: persistSelectionRef.current,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tlet next = getNextOption();\n\t\t\t\t\ttransition(NAVIGATE, { value: next ? next.value : null });\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// A lot of duplicate code with ArrowDown up next, I'm already over it.\n\t\t\tcase \"ArrowUp\":\n\t\t\t\tif (!options || !options.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (state === IDLE) {\n\t\t\t\t\tif (textareaHasMultilineValue) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Opening a closed list\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\ttransition(NAVIGATE, {\n\t\t\t\t\t\tpersistSelection: persistSelectionRef.current,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tlet prev = getPreviousOption();\n\t\t\t\t\ttransition(NAVIGATE, { value: prev ? prev.value : null });\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Home\":\n\t\t\tcase \"PageUp\":\n\t\t\t\t// Don't scroll the page\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif (!options || options.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (state === IDLE) {\n\t\t\t\t\ttransition(NAVIGATE);\n\t\t\t\t} else {\n\t\t\t\t\ttransition(NAVIGATE, { value: getFirstOption().value });\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"End\":\n\t\t\tcase \"PageDown\":\n\t\t\t\t// Don't scroll the page\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif (!options || options.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (state === IDLE) {\n\t\t\t\t\ttransition(NAVIGATE);\n\t\t\t\t} else {\n\t\t\t\t\ttransition(NAVIGATE, { value: getLastOption().value });\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Escape\":\n\t\t\t\tif (state !== IDLE) {\n\t\t\t\t\ttransition(ESCAPE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Enter\":\n\t\t\t\tif (state === NAVIGATING && navigationValue !== null) {\n\t\t\t\t\t// don't want to submit forms\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tonSelect && onSelect(navigationValue);\n\t\t\t\t\ttransition(SELECT_WITH_KEYBOARD, {\n\t\t\t\t\t\tisControlled: isControlledRef.current,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\nexport { useKeyDown as unstable_useKeyDown };\n\nfunction useBlur() {\n\tlet { state, transition, popoverRef, inputRef, buttonRef } =\n\t\tReact.useContext(ComboboxContext);\n\n\treturn function handleBlur(event: React.FocusEvent) {\n\t\tlet popover = popoverRef.current;\n\t\tlet input = inputRef.current;\n\t\tlet button = buttonRef.current;\n\t\tlet activeElement = event.relatedTarget as Node;\n\n\t\t// we on want to close only if focus propss outside the combobox\n\t\tif (activeElement !== input && activeElement !== button && popover) {\n\t\t\tif (popover.contains(activeElement)) {\n\t\t\t\t// focus landed inside the combobox, keep it open\n\t\t\t\tif (state !== INTERACTING) {\n\t\t\t\t\ttransition(INTERACT);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// focus landed outside the combobox, close it.\n\t\t\t\ttransition(BLUR);\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * This manages transitions between states with a built in reducer to manage\n * the data that goes with those transitions.\n *\n * @param chart\n * @param reducer\n * @param initialData\n */\nfunction useReducerMachine(\n\tchart: StateChart,\n\treducer: Reducer,\n\tinitialData: Partial<StateData>\n): [State, StateData, Transition] {\n\tlet [state, setState] = React.useState(chart.initial);\n\tlet [data, dispatch] = React.useReducer(reducer, initialData);\n\n\tlet transition: Transition = (event, payload = {}) => {\n\t\tlet currentState = chart.states[state];\n\t\tlet nextState = currentState && currentState.on[event];\n\t\tif (nextState) {\n\t\t\tdispatch({ type: event, state, nextState: state, ...payload });\n\t\t\tsetState(nextState);\n\t\t\treturn;\n\t\t}\n\t};\n\n\treturn [state, data, transition];\n}\n\n/**\n * We don't want to track the active descendant with indexes because nothing is\n * more annoying in a combobox than having it change values RIGHT AS YOU HIT\n * ENTER. That only happens if you use the index as your data, rather than\n * *your data as your data*. We use this to generate a unique ID based on the\n * value of each item.  This function is short, sweet, and good enough™ (I also\n * don't know how it works, tbqh)\n *\n * @see https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\n * @param str\n */\nfunction makeHash(str: string) {\n\tlet hash = 0;\n\tif (str.length === 0) {\n\t\treturn hash;\n\t}\n\tfor (let i = 0; i < str.length; i++) {\n\t\thash = (hash << 5) - hash + str.charCodeAt(i);\n\t\thash = hash & hash;\n\t}\n\treturn hash;\n}\n\n// function getActiveElement(node: Element | null | undefined) {\n//   let activeElement: Element | null = null;\n//   try {\n//     // If Element.getRootNode is supported, we'll retrieve either the root\n//     // Document or shadow root depending on where the component is rendered.\n//     // https://github.com/reach/reach-ui/issues/787\n//     activeElement = (node?.getRootNode() as ShadowRoot | Document)\n//       .activeElement;\n//   } finally {\n//     return activeElement || (node?.ownerDocument || document).activeElement;\n//   }\n// }\n\nfunction getDataState(state: State) {\n\treturn state.toLowerCase();\n}\n\n/**\n * Escape regexp special characters in `str`\n *\n * @see https://github.com/component/escape-regexp/blob/5ce923c1510c9802b3da972c90b6861dd2829b6b/index.js\n * @param str\n */\n\nexport function escapeRegexp(str: string) {\n\treturn String(str).replace(/([.*+?=^!:${}()|[\\]/\\\\])/g, \"\\\\$1\");\n}\n\n//////////////////////////\n//////////////////////////////////////////////////////\n\n/**\n * A hook that exposes data for a given `Combobox` component to its descendants.\n *\n * @see Docs https://reach.tech/combobox#usecomboboxcontext\n */\nexport function useComboboxContext(): ComboboxContextValue {\n\tlet { isExpanded, comboboxId, data, state } =\n\t\tReact.useContext(ComboboxContext);\n\tlet { navigationValue } = data;\n\treturn React.useMemo(\n\t\t() => ({\n\t\t\tid: comboboxId,\n\t\t\tisExpanded,\n\t\t\tnavigationValue: navigationValue ?? null,\n\t\t\tstate,\n\t\t}),\n\t\t[comboboxId, isExpanded, navigationValue, state]\n\t);\n}\n\n/**\n * A hook that exposes data for a given `ComboboxOption` component to its descendants.\n *\n * @see Docs https://reach.tech/combobox#usecomboboxcontext\n */\nexport function useComboboxOptionContext(): ComboboxOptionContextValue {\n\tlet { value, index } = React.useContext(OptionContext);\n\treturn React.useMemo(\n\t\t() => ({\n\t\t\tvalue,\n\t\t\tindex,\n\t\t}),\n\t\t[value, index]\n\t);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Well alright, you made it all the way here to like 1100 lines of code (geez,\n// what the heck?). Have a great day :D\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\nexport interface ComboboxContextValue {\n\tid: string | undefined;\n\tisExpanded: boolean;\n\tnavigationValue: ComboboxValue | null;\n\tstate: State;\n}\n\ntype ComboboxDescendant = Descendant<HTMLElement> & {\n\tvalue: ComboboxValue;\n};\n\ninterface ComboboxOptionContextValue {\n\tvalue: ComboboxValue;\n\tindex: number;\n}\n\ninterface InternalComboboxContextValue {\n\tariaLabel?: string;\n\tariaLabelledby?: string;\n\tautocompletePropRef: React.MutableRefObject<any>;\n\tbuttonRef: React.MutableRefObject<HTMLButtonElement | undefined>;\n\tcomboboxId: string | undefined;\n\tdata: StateData;\n\tinputRef: React.MutableRefObject<HTMLInputElement | undefined>;\n\tisExpanded: boolean;\n\tlistboxId: string;\n\tonSelect(value?: ComboboxValue): any;\n\topenOnFocus: boolean;\n\tpersistSelectionRef: React.MutableRefObject<boolean>;\n\tpopoverRef: React.MutableRefObject<HTMLElement | undefined>;\n\tstate: State;\n\ttransition: Transition;\n\tisControlledRef: React.MutableRefObject<boolean>;\n}\n\ntype Transition = (event: MachineEventType, payload?: any) => any;\n\ntype ComboboxValue = string;\n\ntype State = \"IDLE\" | \"SUGGESTING\" | \"NAVIGATING\" | \"INTERACTING\";\n\ntype MachineEventType =\n\t| \"CLEAR\"\n\t| \"CHANGE\"\n\t| \"INITIAL_CHANGE\"\n\t| \"NAVIGATE\"\n\t| \"SELECT_WITH_KEYBOARD\"\n\t| \"SELECT_WITH_CLICK\"\n\t| \"ESCAPE\"\n\t| \"BLUR\"\n\t| \"INTERACT\"\n\t| \"FOCUS\"\n\t| \"OPEN_WITH_INPUT_CLICK\"\n\t| \"OPEN_WITH_BUTTON\"\n\t| \"CLOSE_WITH_BUTTON\";\n\ninterface StateChart {\n\tinitial: State;\n\tstates: {\n\t\t[key in State]?: {\n\t\t\ton: {\n\t\t\t\t[key in MachineEventType]?: State;\n\t\t\t};\n\t\t};\n\t};\n}\n\ninterface StateData {\n\tlastEventType?: MachineEventType;\n\tnavigationValue?: ComboboxValue | null;\n\tvalue?: ComboboxValue | null;\n}\n\ntype MachineEvent =\n\t| { type: \"BLUR\" }\n\t| { type: \"CHANGE\"; value: ComboboxValue }\n\t| { type: \"INITIAL_CHANGE\"; value: ComboboxValue }\n\t| { type: \"CLEAR\" }\n\t| { type: \"CLOSE_WITH_BUTTON\" }\n\t| { type: \"ESCAPE\" }\n\t| { type: \"FOCUS\" }\n\t| { type: \"INTERACT\" }\n\t| {\n\t\t\ttype: \"NAVIGATE\";\n\t\t\tpersistSelection?: boolean;\n\t\t\tvalue: ComboboxValue;\n\t  }\n\t| { type: \"OPEN_WITH_BUTTON\" }\n\t| { type: \"OPEN_WITH_INPUT_CLICK\" }\n\t| {\n\t\t\ttype: \"SELECT_WITH_CLICK\";\n\t\t\tvalue: ComboboxValue;\n\t\t\tisControlled: boolean;\n\t  }\n\t| {\n\t\t\ttype: \"SELECT_WITH_KEYBOARD\";\n\t\t\tisControlled: boolean;\n\t  };\n\ntype Reducer = (data: StateData, event: MachineEvent) => StateData;\n","// Forked from https://github.com/bvaughn/highlight-words-core\n\n/**\n * Creates an array of chunk objects representing both higlightable and non\n * highlightable pieces of text that match each search word.\n *\n * @return Array of \"chunk\" objects\n */\nfunction findAll({\n\tautoEscape,\n\tcaseSensitive = false,\n\tfindChunks = defaultFindChunks,\n\tsanitize,\n\tsearchWords,\n\ttextToHighlight,\n}: {\n\tautoEscape?: boolean;\n\tcaseSensitive?: boolean;\n\tfindChunks?: typeof defaultFindChunks;\n\tsanitize?: typeof defaultSanitize;\n\tsearchWords: string[];\n\ttextToHighlight?: string | null;\n}): Chunk[] {\n\treturn fillInChunks({\n\t\tchunksToHighlight: combineChunks({\n\t\t\tchunks: findChunks({\n\t\t\t\tautoEscape,\n\t\t\t\tcaseSensitive,\n\t\t\t\tsanitize,\n\t\t\t\tsearchWords,\n\t\t\t\ttextToHighlight,\n\t\t\t}),\n\t\t}),\n\t\ttotalLength: textToHighlight ? textToHighlight.length : 0,\n\t});\n}\n\n/**\n * Takes an array of \"chunk\" objects and combines chunks that overlap into\n * single chunks.\n *\n * @return Array of \"chunk\" objects\n */\nfunction combineChunks({ chunks }: { chunks: Chunk[] }): Chunk[] {\n\treturn chunks\n\t\t.sort((first, second) => first.start - second.start)\n\t\t.reduce<Chunk[]>((processedChunks, nextChunk) => {\n\t\t\t// First chunk just goes straight in the array...\n\t\t\tif (processedChunks.length === 0) {\n\t\t\t\treturn [nextChunk];\n\t\t\t} else {\n\t\t\t\t// ... subsequent chunks get checked to see if they overlap...\n\t\t\t\tconst prevChunk = processedChunks.pop()!;\n\t\t\t\tif (nextChunk.start <= prevChunk.end) {\n\t\t\t\t\t// It may be the case that prevChunk completely surrounds nextChunk, so take the\n\t\t\t\t\t// largest of the end indeces.\n\t\t\t\t\tconst endIndex = Math.max(prevChunk.end, nextChunk.end);\n\t\t\t\t\tprocessedChunks.push({\n\t\t\t\t\t\thighlight: false,\n\t\t\t\t\t\tstart: prevChunk.start,\n\t\t\t\t\t\tend: endIndex,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tprocessedChunks.push(prevChunk, nextChunk);\n\t\t\t\t}\n\t\t\t\treturn processedChunks;\n\t\t\t}\n\t\t}, []);\n}\n\n/**\n * Examine text for any matches. If we find matches, add them to the returned\n * array as a \"chunk\" object.\n *\n * @return Array of \"chunk\" objects\n */\nfunction defaultFindChunks({\n\tautoEscape,\n\tcaseSensitive,\n\tsanitize = defaultSanitize,\n\tsearchWords,\n\ttextToHighlight,\n}: {\n\tautoEscape?: boolean;\n\tcaseSensitive?: boolean;\n\tsanitize?: typeof defaultSanitize;\n\tsearchWords: string[];\n\ttextToHighlight?: string | null;\n}): Chunk[] {\n\ttextToHighlight = sanitize(textToHighlight || \"\");\n\n\treturn searchWords\n\t\t.filter((searchWord) => searchWord) // Remove empty words\n\t\t.reduce<Chunk[]>((chunks, searchWord) => {\n\t\t\tsearchWord = sanitize(searchWord);\n\n\t\t\tif (autoEscape) {\n\t\t\t\tsearchWord = escapeRegExpFn(searchWord);\n\t\t\t}\n\n\t\t\tconst regex = new RegExp(searchWord, caseSensitive ? \"g\" : \"gi\");\n\n\t\t\tlet match;\n\t\t\twhile ((match = regex.exec(textToHighlight || \"\"))) {\n\t\t\t\tlet start = match.index;\n\t\t\t\tlet end = regex.lastIndex;\n\t\t\t\t// We do not return zero-length matches\n\t\t\t\tif (end > start) {\n\t\t\t\t\tchunks.push({ highlight: false, start, end });\n\t\t\t\t}\n\n\t\t\t\t// Prevent browsers like Firefox from getting stuck in an infinite loop\n\t\t\t\t// See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n\t\t\t\tif (match.index === regex.lastIndex) {\n\t\t\t\t\tregex.lastIndex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn chunks;\n\t\t}, []);\n}\n\n/**\n * Given a set of chunks to highlight, create an additional set of chunks\n * to represent the bits of text between the highlighted text.\n *\n * @return Array of \"chunk\" objects\n */\nfunction fillInChunks({\n\tchunksToHighlight,\n\ttotalLength,\n}: {\n\tchunksToHighlight: Chunk[];\n\ttotalLength: number;\n}): Chunk[] {\n\tconst allChunks: Chunk[] = [];\n\n\tif (chunksToHighlight.length === 0) {\n\t\tappend(0, totalLength, false);\n\t} else {\n\t\tlet lastIndex = 0;\n\t\tchunksToHighlight.forEach((chunk) => {\n\t\t\tappend(lastIndex, chunk.start, false);\n\t\t\tappend(chunk.start, chunk.end, true);\n\t\t\tlastIndex = chunk.end;\n\t\t});\n\t\tappend(lastIndex, totalLength, false);\n\t}\n\treturn allChunks;\n\n\tfunction append(start: number, end: number, highlight: boolean) {\n\t\tif (end - start > 0) {\n\t\t\tallChunks.push({\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\thighlight,\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction defaultSanitize(string: string): string {\n\treturn string;\n}\n\nfunction escapeRegExpFn(string: string): string {\n\treturn string.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\n}\n\nexport const HighlightWords = {\n\tcombineChunks,\n\tfillInChunks,\n\tfindAll,\n\tfindChunks: defaultFindChunks,\n};\n\nexport interface Chunk {\n\thighlight: boolean;\n\tstart: number;\n\tend: number;\n}\n"],"mappings":"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","names":[]}