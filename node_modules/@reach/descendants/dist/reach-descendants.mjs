"use strict";
/**
  * @reach/descendants v0.18.0
  *
  * Copyright (c) 2018-2022, React Training LLC
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */


// src/reach-descendants.tsx
import * as React from "react";
import {
  useForceUpdate,
  useIsomorphicLayoutEffect as useLayoutEffect,
  noop
} from "@reach/utils";
function createDescendantContext(name, initialValue = {}) {
  const descendants = [];
  let ctx = React.createContext({
    descendants,
    registerDescendant: () => noop,
    ...initialValue
  });
  ctx.displayName = name;
  return ctx;
}
function useDescendant(descendant, context, indexProp) {
  let forceUpdate = useForceUpdate();
  let { registerDescendant, descendants } = React.useContext(context);
  let index = indexProp ?? descendants.findIndex((item) => item.element === descendant.element);
  useLayoutEffect(() => {
    if (!descendant.element)
      forceUpdate();
    return registerDescendant({ ...descendant, index });
  }, [
    descendant,
    forceUpdate,
    index,
    registerDescendant,
    ...Object.values(descendant)
  ]);
  return index;
}
function useDescendantsInit() {
  return React.useState([]);
}
function useDescendants(ctx) {
  return React.useContext(ctx).descendants;
}
function DescendantProvider({
  context: Ctx,
  children,
  items,
  set
}) {
  let registerDescendant = React.useCallback(({
    element,
    index: explicitIndex,
    ...rest
  }) => {
    if (!element)
      return noop;
    set((items2) => {
      if (explicitIndex != null && explicitIndex !== -1) {
        return insertAt(items2, { element, index: explicitIndex, ...rest }, explicitIndex);
      }
      if (items2.length === 0) {
        return [{ ...rest, element, index: 0 }];
      }
      if (true) {
        if (items2.find((item) => item.element === element)) {
          console.warn("[reach-ui]: `useDescendant` was called with an element that was already registered.\n\nIf you are using the `@reach/descendants` package directly, make sure to only register descendants once. Registering a descendant more than once will lead to bugs in your app.\n\nIf you are using another `reach-ui` package, this is probably our bug!\n\nTo report a bug, open a new issue:\n\n  https://github.com/reach/reach-ui/issues/new?assignees=&labels=&template=Bug_report.md\n\nIMPORTANT: this check will only run in the development build, so if you see this warning please be aware that your app may crash when deployed.");
          return updateIndices(items2);
        }
      }
      let index = findDOMIndex(items2, element);
      let newItems;
      if (index === -1) {
        newItems = [
          ...items2,
          { ...rest, element, index: items2.length }
        ];
      } else {
        newItems = insertAt(items2, { ...rest, element, index }, index);
      }
      return newItems;
    });
    return () => {
      if (!element)
        return;
      set((items2) => items2.filter((item) => element !== item.element));
    };
  }, []);
  return /* @__PURE__ */ React.createElement(Ctx.Provider, {
    value: React.useMemo(() => {
      return {
        descendants: items,
        registerDescendant
      };
    }, [items, registerDescendant])
  }, children);
}
function useDescendantKeyDown(context, options) {
  let { descendants } = React.useContext(context);
  let {
    callback,
    currentIndex,
    filter,
    key = "index",
    orientation = "vertical",
    rotate = true,
    rtl = false
  } = options;
  return function handleKeyDown(event) {
    if (![
      "ArrowDown",
      "ArrowUp",
      "ArrowLeft",
      "ArrowRight",
      "PageUp",
      "PageDown",
      "Home",
      "End"
    ].includes(event.key)) {
      return;
    }
    let index = currentIndex ?? -1;
    let selectableDescendants = filter ? descendants.filter(filter) : descendants;
    if (!selectableDescendants.length) {
      return;
    }
    let selectableIndex = selectableDescendants.findIndex((descendant) => descendant.index === currentIndex);
    function getNextOption() {
      let atBottom = index === getLastOption().index;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];
    }
    function getPreviousOption() {
      let atTop = index === getFirstOption().index;
      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];
    }
    function getFirstOption() {
      return selectableDescendants[0];
    }
    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }
    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          let next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          let prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }
        break;
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }
        break;
      case "PageUp":
        event.preventDefault();
        let prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;
      case "Home":
        event.preventDefault();
        let first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;
      case "PageDown":
        event.preventDefault();
        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;
      case "End":
        event.preventDefault();
        let last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  };
}
function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, element) {
  if (!element)
    return -1;
  if (!items.length)
    return -1;
  let length = items.length;
  while (length--) {
    let currentElement = items[length].element;
    if (!currentElement)
      continue;
    if (isElementPreceding(currentElement, element)) {
      return length + 1;
    }
  }
  return -1;
}
function insertAt(array, item, index) {
  if (index == null || !(index in array)) {
    return [...array, item];
  }
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function updateIndices(items) {
  return items.sort((a, b) => !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1).map((item, index) => ({ ...item, index }));
}
export {
  DescendantProvider,
  createDescendantContext,
  useDescendant,
  useDescendantKeyDown,
  useDescendants,
  useDescendantsInit
};
