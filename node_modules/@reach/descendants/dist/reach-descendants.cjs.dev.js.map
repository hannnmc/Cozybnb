{"version":3,"sources":["../src/reach-descendants.tsx"],"sourcesContent":["import * as React from \"react\";\nimport {\n\tuseForceUpdate,\n\tuseIsomorphicLayoutEffect as useLayoutEffect,\n\tnoop,\n} from \"@reach/utils\";\n\ndeclare const __DEV__: boolean;\n\nfunction createDescendantContext<DescendantType extends Descendant>(\n\tname: string,\n\tinitialValue = {}\n) {\n\ttype T = DescendantContextValue<DescendantType>;\n\tconst descendants: DescendantType[] = [];\n\tlet ctx = React.createContext<T>({\n\t\tdescendants,\n\t\tregisterDescendant: () => noop,\n\t\t...initialValue,\n\t});\n\tctx.displayName = name;\n\treturn ctx;\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nfunction useDescendant<DescendantType extends Descendant>(\n\tdescendant: Omit<DescendantType, \"index\">,\n\tcontext: React.Context<DescendantContextValue<DescendantType>>,\n\tindexProp?: number\n) {\n\tlet forceUpdate = useForceUpdate();\n\tlet { registerDescendant, descendants } = React.useContext(context);\n\n\t// This will initially return -1 because we haven't registered the descendant\n\t// on the first render. After we register, this will then return the correct\n\t// index on the following render and we will re-register descendants so that\n\t// everything is up-to-date before the user interacts with a collection.\n\tlet index =\n\t\tindexProp ??\n\t\tdescendants.findIndex((item) => item.element === descendant.element);\n\n\t// Prevent any flashing\n\tuseLayoutEffect(() => {\n\t\tif (!descendant.element) forceUpdate();\n\t\treturn registerDescendant({ ...descendant, index } as DescendantType);\n\t}, [\n\t\tdescendant,\n\t\tforceUpdate,\n\t\tindex,\n\t\tregisterDescendant,\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t...Object.values(descendant),\n\t]);\n\n\treturn index;\n}\n\nfunction useDescendantsInit<DescendantType extends Descendant>() {\n\treturn React.useState<DescendantType[]>([]);\n}\n\nfunction useDescendants<DescendantType extends Descendant>(\n\tctx: React.Context<DescendantContextValue<DescendantType>>\n) {\n\treturn React.useContext(ctx).descendants;\n}\n\nfunction DescendantProvider<DescendantType extends Descendant>({\n\tcontext: Ctx,\n\tchildren,\n\titems,\n\tset,\n}: {\n\tcontext: React.Context<DescendantContextValue<DescendantType>>;\n\tchildren: React.ReactNode;\n\titems: DescendantType[];\n\tset: React.Dispatch<React.SetStateAction<DescendantType[]>>;\n}) {\n\tlet registerDescendant = React.useCallback(\n\t\t({\n\t\t\telement,\n\t\t\tindex: explicitIndex,\n\t\t\t...rest\n\t\t}: Omit<DescendantType, \"index\"> & { index?: number | undefined }) => {\n\t\t\tif (!element) return noop;\n\n\t\t\tset((items) => {\n\t\t\t\tif (explicitIndex != null && explicitIndex !== -1) {\n\t\t\t\t\treturn insertAt(\n\t\t\t\t\t\titems,\n\t\t\t\t\t\t{ element, index: explicitIndex, ...rest } as DescendantType,\n\t\t\t\t\t\texplicitIndex\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (items.length === 0) {\n\t\t\t\t\t// If there are no items, register at index 0 and bail.\n\t\t\t\t\treturn [{ ...rest, element, index: 0 } as DescendantType];\n\t\t\t\t}\n\n\t\t\t\tif (__DEV__) {\n\t\t\t\t\tif (items.find((item) => item.element === element)) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"[reach-ui]: `useDescendant` was called with an element that was \" +\n\t\t\t\t\t\t\t\t\"already registered.\\n\\n\" +\n\t\t\t\t\t\t\t\t\"If you are using the `@reach/descendants` package directly, \" +\n\t\t\t\t\t\t\t\t\"make sure to only register descendants once. Registering a descendant \" +\n\t\t\t\t\t\t\t\t\"more than once will lead to bugs in your app.\\n\\n\" +\n\t\t\t\t\t\t\t\t\"If you are using another `reach-ui` package, this is probably our bug!\\n\\n\" +\n\t\t\t\t\t\t\t\t\"To report a bug, open a new issue:\\n\\n\" +\n\t\t\t\t\t\t\t\t\"  https://github.com/reach/reach-ui/issues/new?assignees=&labels=&template=Bug_report.md\\n\\n\" +\n\t\t\t\t\t\t\t\t\"IMPORTANT: this check will only run in the development build, so if you \" +\n\t\t\t\t\t\t\t\t\"see this warning please be aware that your app may crash when deployed.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn updateIndices(items);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet index = findDOMIndex(items, element);\n\t\t\t\tlet newItems: DescendantType[];\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tnewItems = [\n\t\t\t\t\t\t...items,\n\t\t\t\t\t\t{ ...rest, element, index: items.length } as DescendantType,\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tnewItems = insertAt(\n\t\t\t\t\t\titems,\n\t\t\t\t\t\t{ ...rest, element, index } as DescendantType,\n\t\t\t\t\t\tindex\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn newItems;\n\t\t\t});\n\n\t\t\treturn () => {\n\t\t\t\tif (!element) return;\n\t\t\t\tset((items) => items.filter((item) => element !== item.element));\n\t\t\t};\n\t\t},\n\t\t// set is a state setter initialized by the useDescendantsInit hook.\n\t\t// We can safely ignore the lint warning here because it will not change\n\t\t// between renders.\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t[]\n\t);\n\n\treturn (\n\t\t<Ctx.Provider\n\t\t\tvalue={React.useMemo(() => {\n\t\t\t\treturn {\n\t\t\t\t\tdescendants: items,\n\t\t\t\t\tregisterDescendant,\n\t\t\t\t};\n\t\t\t}, [items, registerDescendant])}\n\t\t>\n\t\t\t{children}\n\t\t</Ctx.Provider>\n\t);\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nfunction useDescendantKeyDown<\n\tDescendantType extends Descendant,\n\tK extends keyof DescendantType = keyof DescendantType\n>(\n\tcontext: React.Context<DescendantContextValue<DescendantType>>,\n\toptions: {\n\t\tcurrentIndex: number | null | undefined;\n\t\tkey?: K | \"option\";\n\t\tfilter?: (descendant: DescendantType) => boolean;\n\t\torientation?: \"vertical\" | \"horizontal\" | \"both\";\n\t\trotate?: boolean;\n\t\trtl?: boolean;\n\t\tcallback(nextOption: DescendantType | DescendantType[K]): void;\n\t}\n) {\n\tlet { descendants } = React.useContext(context);\n\tlet {\n\t\tcallback,\n\t\tcurrentIndex,\n\t\tfilter,\n\t\tkey = \"index\" as K,\n\t\torientation = \"vertical\",\n\t\trotate = true,\n\t\trtl = false,\n\t} = options;\n\n\treturn function handleKeyDown(event: React.KeyboardEvent) {\n\t\tif (\n\t\t\t![\n\t\t\t\t\"ArrowDown\",\n\t\t\t\t\"ArrowUp\",\n\t\t\t\t\"ArrowLeft\",\n\t\t\t\t\"ArrowRight\",\n\t\t\t\t\"PageUp\",\n\t\t\t\t\"PageDown\",\n\t\t\t\t\"Home\",\n\t\t\t\t\"End\",\n\t\t\t].includes(event.key)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet index = currentIndex ?? -1;\n\n\t\t// If we use a filter function, we need to re-index our descendants array\n\t\t// so that filtered descendent elements aren't selected.\n\t\tlet selectableDescendants = filter\n\t\t\t? descendants.filter(filter)\n\t\t\t: descendants;\n\n\t\t// We need some options for any of this to work!\n\t\tif (!selectableDescendants.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet selectableIndex = selectableDescendants.findIndex(\n\t\t\t(descendant) => descendant.index === currentIndex\n\t\t);\n\n\t\tfunction getNextOption() {\n\t\t\tlet atBottom = index === getLastOption().index;\n\t\t\treturn atBottom\n\t\t\t\t? rotate\n\t\t\t\t\t? getFirstOption()\n\t\t\t\t\t: selectableDescendants[selectableIndex]\n\t\t\t\t: selectableDescendants[\n\t\t\t\t\t\t(selectableIndex + 1) % selectableDescendants.length\n\t\t\t\t  ];\n\t\t}\n\n\t\tfunction getPreviousOption() {\n\t\t\tlet atTop = index === getFirstOption().index;\n\t\t\treturn atTop\n\t\t\t\t? rotate\n\t\t\t\t\t? getLastOption()\n\t\t\t\t\t: selectableDescendants[selectableIndex]\n\t\t\t\t: selectableDescendants[\n\t\t\t\t\t\t(selectableIndex - 1 + selectableDescendants.length) %\n\t\t\t\t\t\t\tselectableDescendants.length\n\t\t\t\t  ];\n\t\t}\n\n\t\tfunction getFirstOption() {\n\t\t\treturn selectableDescendants[0];\n\t\t}\n\n\t\tfunction getLastOption() {\n\t\t\treturn selectableDescendants[selectableDescendants.length - 1];\n\t\t}\n\n\t\tswitch (event.key) {\n\t\t\tcase \"ArrowDown\":\n\t\t\t\tif (orientation === \"vertical\" || orientation === \"both\") {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tlet next = getNextOption();\n\t\t\t\t\tcallback(key === \"option\" ? next : next[key]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowUp\":\n\t\t\t\tif (orientation === \"vertical\" || orientation === \"both\") {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tlet prev = getPreviousOption();\n\t\t\t\t\tcallback(key === \"option\" ? prev : prev[key]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowLeft\":\n\t\t\t\tif (orientation === \"horizontal\" || orientation === \"both\") {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tlet nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n\t\t\t\t\tcallback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowRight\":\n\t\t\t\tif (orientation === \"horizontal\" || orientation === \"both\") {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tlet prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n\t\t\t\t\tcallback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"PageUp\":\n\t\t\t\tevent.preventDefault();\n\t\t\t\tlet prevOrFirst = (\n\t\t\t\t\tevent.ctrlKey ? getPreviousOption : getFirstOption\n\t\t\t\t)();\n\t\t\t\tcallback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n\t\t\t\tbreak;\n\t\t\tcase \"Home\":\n\t\t\t\tevent.preventDefault();\n\t\t\t\tlet first = getFirstOption();\n\t\t\t\tcallback(key === \"option\" ? first : first[key]);\n\t\t\t\tbreak;\n\t\t\tcase \"PageDown\":\n\t\t\t\tevent.preventDefault();\n\t\t\t\tlet nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n\t\t\t\tcallback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n\t\t\t\tbreak;\n\t\t\tcase \"End\":\n\t\t\t\tevent.preventDefault();\n\t\t\t\tlet last = getLastOption();\n\t\t\t\tcallback(key === \"option\" ? last : last[key]);\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\nfunction isElementPreceding(a: Element, b: Element) {\n\treturn Boolean(\n\t\tb.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING\n\t);\n}\n\nfunction findDOMIndex<DescendantType extends Descendant>(\n\titems: DescendantType[],\n\telement: Element\n) {\n\tif (!element) return -1;\n\tif (!items.length) return -1;\n\n\tlet length = items.length;\n\t// Most of the times, the new item will be added at the end of the list, so we\n\t// do a findeIndex in reverse order, instead of wasting time searching the\n\t// index from the beginning.\n\twhile (length--) {\n\t\tlet currentElement = items[length].element;\n\t\tif (!currentElement) continue;\n\t\tif (isElementPreceding(currentElement, element)) {\n\t\t\treturn length + 1;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Copy an array of items with a new item added at a specific index.\n * @param array The source array\n * @param item The item to insert into the array\n * @param index The index to insert the item at\n * @returns A copy of the array with the item inserted at the specified index\n */\nfunction insertAt<T extends any[]>(\n\tarray: T,\n\titem: T[number],\n\tindex?: number\n): T {\n\tif (index == null || !(index in array)) {\n\t\treturn [...array, item] as T;\n\t}\n\treturn [...array.slice(0, index), item, ...array.slice(index)] as T;\n}\n\nfunction updateIndices<DescendantType extends Descendant>(\n\titems: DescendantType[]\n): DescendantType[] {\n\treturn items\n\t\t.sort((a, b) =>\n\t\t\t!a.element || !b.element\n\t\t\t\t? 0\n\t\t\t\t: isElementPreceding(a.element, b.element)\n\t\t\t\t? -1\n\t\t\t\t: 1\n\t\t)\n\t\t.map((item, index) => ({ ...item, index }));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeElement<T> = T extends Element ? T : HTMLElement;\n\ntype Descendant<ElementType = HTMLElement> = {\n\telement: SomeElement<ElementType> | null;\n\tindex: number;\n};\n\ninterface DescendantContextValue<DescendantType extends Descendant> {\n\tdescendants: DescendantType[];\n\tregisterDescendant(descendant: DescendantType): () => void;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Exports\n\nexport type { Descendant, DescendantContextValue };\nexport {\n\tcreateDescendantContext,\n\tDescendantProvider,\n\tuseDescendant,\n\tuseDescendantKeyDown,\n\tuseDescendants,\n\tuseDescendantsInit,\n};\n"],"mappings":"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","names":[]}